### 1. Какой самый эффективный способ конкатенации строк?

- Самым эффективным способом конкатенации строк является использование strings.Builder. Этот метод минимизирует количество аллокаций памяти, что делает его предпочтительным выбором для высокопроизводительных операций.

- var sb strings.Builder - объект в котором содержится буфер
strings.Builder.WriteString(str) - сохраняет str в буфер для дальнейшей работы со строками. 
strings.Builder.String() возвращает буффер в виде стооки, в котором сохранены все строки

### 2. Что такое интерфейсы, как они применяются в Go?

- Интерфейсы это абстрактный тип данных . Интерфейс объявляет методы или типы данных, которыми обязан обладать объект.
Они применяются когда мы хотим вызвать какую либо функцию или указать неявный тип данных без привязки к определенному объекту.

### 3. Чем отличаются RWMutex от Mutex?

- RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать.
- Перед записью в защищаемый мьютексом объект делается .Lock(), а вызовы .Lock() и .RLock() в других горутинах будут ждать, пока вы не отпустите мьютекс через .Unlock().
Перед чтением защищаемого объекта делается .RLock() и только вызовы .Lock() в других горутинах блокируются, вызовы .RLock() спокойно проходят. Когда отпускаете мьютекс через .RUnlock(), ждущие вызовы .Lock() по-очереди могут забирать мьютекс на себя.

### 4. Чем отличаются буферизированные и не буферизированные каналы?

- Небуферезированные каналы блокируют горутину до тех пор пока в канал не будет что то записано или считано.
- А буферезированный канал не блокирует при условии что из канала можно что то считать или он не заполнен.

### 5. Какой размер у структуры struct{}{}?

- Cама структура занимает 0 байт, но конечно же есть накладные расходы на ее объявление, хранение указателя, ссылки.

### 6. Есть ли в Go перегрузка методов или операторов?

- Нет, в Go нет перегрузки методов и операторов. Но можно давать одинаковые имена методам которые принадлежат разным структурам.

### 7. В какой последовательности будут выведены элементы map[int]int?

- Элементы map[int]int будут выведены в различном порядке так как результат зависит от результата работы хеш-функции и каким образом будут храниться элементы в bucket у которых одинаковое значение хеш-функции

### 8. В чем разница make и new?

- make создает и возвращает инициализированный объект, который уже можно использовать. Так же
для инициализации и создания он принимает только 3 типа данных - map, chan, slice. Можно задать capacity для создаваемого объекта.

- new инициализирует нулевое значение для данного типа и возвращает указатель на этот тип.

### 9. Сколько существует способов задать переменную типа slice или map?

- Для типа slice можно задать 6 способами:

        var slice []Type
        slice := []Type{}
        slice := make([]Type, length)
        slice := []Type{value1, value2, ...}
        slice := make([]Type, length, capacity)
        slice := new([]Type)

- Для типа map 4 cпособами: 

        var mapName map[KeyType]ValueType
        mapName := make(map[KeyType]ValueType)
        mapName := map[KeyType]ValueType{key1: value1, key2: value2, ...}
        mapPtr := new(map[KeyType]ValueType)


### 10. Что выведет данная программа и почему?

        func update(p *int) {
        b := 2
        p = &b
        }

        func main() {
        var (
            a = 1
            p = &a
        )
        fmt.Println(*p)
        update(p)
        fmt.Println(*p)
        }

Данная функция выведет:

        1
        1

Потому что в первый раз мы положили в указатель `p` адрес переменной `a` и тепере указатель указывает на значение переменной `a` , внутри функции  update(p *int) создает копия указателя и там мы меняем значение указателя на новый адрес переменной `b`. Но оригинальный указатель так же остался неизменным. Т.к. значение поменяли в копии оригинального указателя. 
Если бы мы захотели поменять значение в оригинальном указателе, то мы могли бы переделать функцию `update(p **int)` и передатать сюда адрес нашего оригинального указателя и при разыменовании p **int мы поменяли бы значение  `*p = &b`.

### 11. Что выведет данная программа и почему?

        func main() {
        wg := sync.WaitGroup{}
        for i := 0; i < 5; i++ {
            wg.Add(1)
            go func(wg sync.WaitGroup, i int) {
                fmt.Println(i)
                wg.Done()
            }(wg, i)
        }
        wg.Wait()
        fmt.Println("exit")
        }

Сначала бы вывелись все значения в рандомном порядке от 0 до 4 т.к. в цикле мы запускаем горутины конкурентно и неизвестно в каком порядке они будут запущены. 
Затем случится `deadlock`,  потому что сбрасывать счетчик `WhaitGroup` нужно из глобальной переменной `wg` , ведь при создании тут добавлен аргумент `wg` и при вызове анонимной функции будет создана копия объекта `wg`, а оригинальная изменяться не будет и счетчик будет иметь значение 5.
Если бы мы удалили аргумент `wg`, то анонимная функция могла бы работать с глобальной `wg` или изменить в параметрах функции func(wg sync.WaitGroup, i int) на func(wg *sync.WaitGroup, i int),
тогда мы меняли бы значение по указателю.

### 12. Что выведет данная программа и почему?

        func main() {
        n := 0
        if true {
            n := 1
            n++
        }
        fmt.Println(n)
        }

Данная программа выведет 0, потому что внутри if существует своя область видимости.
В области видимости уровнем выше переменная n не будет изменена.

### 13. Что выведет данная программа и почему?

        func someAction(v []int8, b int8) {
        v[0] = 100
        v = append(v, b)
        }

        func main() {
        var a = []int8{1, 2, 3, 4, 5}
        someAction(a, 6)
        fmt.Println(a)
        }

Данная программа выведет слайс `[100 2 3 4 5]` потому что внутри функции `someAction(v []int8, b int8)` создается копия слайса a, но внутри этих слайсов содержится указатель на один и тот же массив.  `v[0]` будет указывать на тот же элемент массива что и `a[0]` поэтому значение в оригинале так же изменится , но цифра `6` в оригинале не добавится , потому что при добавлении элемента через `append` в `v` перевыделится память потому что слайс не буферезированный и в итоге массивы внутри слайсов будут разные . 
 
 ### 14. Что выведет данная программа и почему?

        func main() {
        slice := []string{"a", "a"}

        func(slice []string) {
            slice = append(slice, "a")
            slice[0] = "b"
            slice[1] = "b"
            fmt.Print(slice)
        }(slice)
        fmt.Print(slice)
        }

В данно программе выведет: `[b b a][a a]` потому что в анонимной функции мы используем копию оригинального слайса. Так как наш слайс не буферезированный то при добавлении элемента в копию память перевыделится и указатели внутри слайсов буду указывать на разные области памяти.  При изменении элементов внутри анонимной функции, в оригинале значения элементов не изменятся.